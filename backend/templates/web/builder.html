{% extends "web/base.html" %}

{% block title %}Builder | Altinet{% endblock %}

{% block content %}
<div class="row g-4">
  <div class="col-12 col-xl-3">
    <div class="card shadow-sm h-100">
      <div class="card-header bg-dark text-white">Toolkit</div>
      <div class="card-body">
        <p class="text-muted small mb-4">
          Configure the baseline measurements used when walls, doors and windows are exported from the builder.
        </p>
        <div class="mb-3">
          <label for="wallHeightInput" class="form-label small text-uppercase fw-semibold text-secondary">
            Wall height (mm)
          </label>
          <input
            type="number"
            class="form-control form-control-sm"
            id="wallHeightInput"
            min="1500"
            max="4500"
            step="10"
          />
        </div>
        <div class="mb-3">
          <label for="wallThicknessInput" class="form-label small text-uppercase fw-semibold text-secondary">
            Wall thickness (mm)
          </label>
          <input
            type="number"
            class="form-control form-control-sm"
            id="wallThicknessInput"
            min="50"
            max="400"
            step="5"
          />
        </div>
        <div class="mb-3">
          <label for="internalDoorWidthInput" class="form-label small text-uppercase fw-semibold text-secondary">
            Internal door width (mm)
          </label>
          <input
            type="number"
            class="form-control form-control-sm"
            id="internalDoorWidthInput"
            min="500"
            max="1200"
            step="5"
          />
        </div>
        <div class="mb-3">
          <label for="externalDoorWidthInput" class="form-label small text-uppercase fw-semibold text-secondary">
            External door width (mm)
          </label>
          <input
            type="number"
            class="form-control form-control-sm"
            id="externalDoorWidthInput"
            min="600"
            max="1600"
            step="5"
          />
        </div>
        <div class="mb-3">
          <label for="windowSillHeightInput" class="form-label small text-uppercase fw-semibold text-secondary">
            Window sill height (mm)
          </label>
          <input
            type="number"
            class="form-control form-control-sm"
            id="windowSillHeightInput"
            min="300"
            max="1500"
            step="10"
          />
        </div>
        <p class="small text-muted mb-0">
          Values are saved with your plan and synchronised to the backend alongside geometry updates.
        </p>
      </div>
    </div>
  </div>
  <div class="col-12 col-xl-6">
    <div class="card shadow-sm h-100">
      <div class="card-header bg-dark text-white d-flex flex-column flex-xl-row gap-3 align-items-start align-items-xl-center justify-content-between">
        <div>
          <div class="d-flex align-items-center gap-2">
            <span class="fw-semibold">Floorplan Builder</span>
            <span class="badge text-bg-secondary" id="activeLevelLabel">Level 1</span>
          </div>
          <p class="small mb-0 text-white-50">
            Switch between levels to sketch multi-storey layouts. Changes are saved locally in your browser.
          </p>
        </div>
        <div class="d-flex flex-wrap gap-2">
          <div class="btn-group" role="group" aria-label="Levels" id="levelTabs"></div>
          <button type="button" class="btn btn-outline-light btn-sm" id="addLevel">
            Add level
          </button>
        </div>
      </div>
      <div class="card-body">
        <div class="d-flex flex-column flex-md-row justify-content-between align-items-start align-items-md-center gap-3 mb-3">
          <div class="btn-group" role="group" aria-label="Builder tools">
            <button type="button" class="btn btn-outline-primary active" data-tool="wall">
              Wall tool
            </button>
            <button type="button" class="btn btn-outline-primary" data-tool="room">
              Room tool
            </button>
          </div>
          <p class="small text-muted mb-0 flex-grow-1 order-3 order-md-2">
            Room tool: click to add vertices, then click the first point or double-click to close the shape.
          </p>
          <div class="d-flex gap-2">
            <button type="button" class="btn btn-outline-secondary" id="undoLast">
              Undo last
            </button>
            <button type="button" class="btn btn-outline-danger" id="clearCanvas">
              Clear level
            </button>
          </div>
        </div>
        <div class="border rounded position-relative" id="builderCanvasContainer">
          <canvas
            id="builderCanvas"
            width="900"
            height="600"
            class="w-100 h-auto"
          ></canvas>
          <div
            id="wallEditor"
            class="position-absolute bg-white border rounded shadow-sm p-3"
            hidden
          >
            <div class="d-flex align-items-start justify-content-between mb-2">
              <div>
                <h3 class="h6 mb-1">Wall settings</h3>
                <p class="small text-muted mb-0">Fine-tune the selected wall.</p>
              </div>
              <button
                type="button"
                class="btn-close"
                aria-label="Close wall settings"
                id="closeWallEditor"
              ></button>
            </div>
            <div class="mb-2">
              <label
                for="wallLengthInput"
                class="form-label small text-uppercase fw-semibold text-secondary"
              >
                Length (mm)
              </label>
              <input
                type="number"
                class="form-control form-control-sm"
                id="wallLengthInput"
                min="1"
                step="1"
              />
            </div>
            <div class="mb-3">
              <label
                for="wallAngleInput"
                class="form-label small text-uppercase fw-semibold text-secondary"
              >
                Angle (°)
              </label>
              <input
                type="number"
                class="form-control form-control-sm"
                id="wallAngleInput"
                step="0.1"
                min="0"
                max="359.9"
              />
            </div>
            <button
              type="button"
              class="btn btn-outline-danger btn-sm w-100"
              id="deleteWallButton"
            >
              Delete wall
            </button>
          </div>
        </div>
        <div class="d-flex flex-column flex-lg-row gap-3 mt-3">
          <div class="flex-grow-1">
            <label for="levelName" class="form-label small text-uppercase fw-semibold text-secondary">
              Active level name
            </label>
            <input type="text" class="form-control" id="levelName" placeholder="e.g. Ground floor" maxlength="40" />
          </div>
          <div class="flex-shrink-0 d-flex flex-column gap-2">
            <button type="button" class="btn btn-outline-secondary" id="duplicateLevel">
              Duplicate level
            </button>
            <button type="button" class="btn btn-outline-danger" id="deleteLevel">
              Delete level
            </button>
          </div>
        </div>
        <div class="alert alert-info mt-3 mb-0" role="alert">
          <h2 class="h6 fw-semibold mb-2">Workflow</h2>
          <ol class="mb-0 small ps-3">
            <li>Sketch each storey of the property using the tools above and switch levels as needed.</li>
            <li>Your changes sync to the backend automatically, triggering a fresh 3D model build for the dashboard viewer.</li>
            <li>Use the export button if you still need a JSON copy for external tools or manual Blender tweaks.</li>
          </ol>
        </div>
      </div>
    </div>
  </div>
  <div class="col-12 col-xl-3">
    <div class="card shadow-sm h-100">
      <div class="card-header bg-dark text-white">Rooms</div>
      <div class="card-body d-flex flex-column">
        <p class="text-muted small">
          Rooms you define are listed here with their area and grid dimensions. Use this as a quick reference while sketching your layout.
        </p>
        <ul class="list-group flex-grow-1" id="roomList"></ul>
        <div class="mt-3">
          <button type="button" class="btn btn-primary w-100" id="exportPlan">Export plan for Blender</button>
          <p class="small text-muted mt-2 mb-0">
            Need an offline copy? Export to <code>.json</code> for Blender or archiving &mdash; the backend already rebuilds the OBJ automatically.
          </p>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  (function () {
    const canvas = document.getElementById("builderCanvas");
    const ctx = canvas.getContext("2d");
    const gridSize = 30;
    const storageKey = "altinet-floorplan";
    const defaultUnitScale = 0.5; // metres per grid unit
    const mmPerGridUnit = defaultUnitScale * 1000;
    const mmPerPixel = mmPerGridUnit / gridSize;
    const metersPerPixel = mmPerPixel / 1000;
    const syncEndpoint = "/api/floorplans/render/";
    const syncDelayMs = 1500;
    const defaultSettings = {
      wallHeightMm: 2400,
      wallThicknessMm: 140,
      internalDoorWidthMm: 762,
      externalDoorWidthMm: 910,
      windowSillHeightMm: 900,
    };
    const roomClosureThreshold = gridSize / 2;
    let lastUpdatedAt = null;
    let syncTimeoutId = null;
    let queuedPayload = null;
    let queuedHash = null;
    let inFlight = false;
    let lastSyncedHash = null;
    let levels = [];
    let activeLevelId = null;
    let needsInitialPersist = false;
    let isDrawing = false;
    let drawingMode = null;
    let startPoint = null;
    let previewPoint = null;
    let activeTool = "wall";
    let selectedWallIndex = null;
    let roomDraftPoints = [];
    let builderSettings = { ...defaultSettings };

    const canvasContainer = document.getElementById("builderCanvasContainer");
    const wallEditor = document.getElementById("wallEditor");
    const wallLengthInput = document.getElementById("wallLengthInput");
    const wallAngleInput = document.getElementById("wallAngleInput");
    const deleteWallButton = document.getElementById("deleteWallButton");
    const closeWallEditorButton = document.getElementById("closeWallEditor");
    const toolButtons = document.querySelectorAll("[data-tool]");
    const roomList = document.getElementById("roomList");
    const clearButton = document.getElementById("clearCanvas");
    const undoButton = document.getElementById("undoLast");
    const levelTabs = document.getElementById("levelTabs");
    const levelNameInput = document.getElementById("levelName");
    const addLevelButton = document.getElementById("addLevel");
    const duplicateLevelButton = document.getElementById("duplicateLevel");
    const deleteLevelButton = document.getElementById("deleteLevel");
    const exportPlanButton = document.getElementById("exportPlan");
    const activeLevelBadge = document.getElementById("activeLevelLabel");
    const settingsInputs = {
      wallHeightMm: document.getElementById("wallHeightInput"),
      wallThicknessMm: document.getElementById("wallThicknessInput"),
      internalDoorWidthMm: document.getElementById("internalDoorWidthInput"),
      externalDoorWidthMm: document.getElementById("externalDoorWidthInput"),
      windowSillHeightMm: document.getElementById("windowSillHeightInput"),
    };

    function getCsrfToken() {
      const name = "csrftoken=";
      const cookies = document.cookie ? document.cookie.split(";") : [];
      for (const cookie of cookies) {
        const trimmed = cookie.trim();
        if (trimmed.startsWith(name)) {
          return decodeURIComponent(trimmed.slice(name.length));
        }
      }
      return "";
    }

    function normaliseSettings(rawSettings) {
      const result = { ...defaultSettings };
      if (rawSettings && typeof rawSettings === "object") {
        Object.entries(rawSettings).forEach(([key, value]) => {
          if (!(key in result)) {
            return;
          }
          const numericValue = Number(value);
          if (Number.isFinite(numericValue)) {
            result[key] = numericValue;
          }
        });
      }
      return result;
    }

    function applySettingsToInputs() {
      Object.entries(settingsInputs).forEach(([key, input]) => {
        if (!input) {
          return;
        }
        const value = builderSettings[key];
        if (typeof value === "number" && !Number.isNaN(value)) {
          input.value = value;
        } else {
          input.value = "";
        }
      });
    }

    function updateSetting(key, value) {
      if (!(key in builderSettings) || !Number.isFinite(value) || value <= 0) {
        return;
      }
      builderSettings = { ...builderSettings, [key]: value };
      persistState();
    }

    function clonePoint(point) {
      if (!point || typeof point.x !== "number" || typeof point.y !== "number") {
        return null;
      }
      return { x: point.x, y: point.y };
    }

    function arePointsEqual(a, b) {
      if (!a || !b) {
        return false;
      }
      return Math.abs(a.x - b.x) < 0.001 && Math.abs(a.y - b.y) < 0.001;
    }

    function distanceBetweenPoints(a, b) {
      if (!a || !b) {
        return Number.POSITIVE_INFINITY;
      }
      return Math.hypot(a.x - b.x, a.y - b.y);
    }

    function calculatePolygonArea(points) {
      if (!Array.isArray(points) || points.length < 3) {
        return 0;
      }
      let sum = 0;
      for (let i = 0; i < points.length; i += 1) {
        const current = points[i];
        const next = points[(i + 1) % points.length];
        sum += current.x * next.y - next.x * current.y;
      }
      return Math.abs(sum) / 2;
    }

    function computePolygonBounds(points) {
      if (!Array.isArray(points) || points.length === 0) {
        return { x: 0, y: 0, width: 0, height: 0 };
      }
      let minX = Number.POSITIVE_INFINITY;
      let minY = Number.POSITIVE_INFINITY;
      let maxX = Number.NEGATIVE_INFINITY;
      let maxY = Number.NEGATIVE_INFINITY;
      points.forEach((point) => {
        minX = Math.min(minX, point.x);
        minY = Math.min(minY, point.y);
        maxX = Math.max(maxX, point.x);
        maxY = Math.max(maxY, point.y);
      });
      return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
    }

    function getPolygonCentroid(points) {
      if (!Array.isArray(points) || points.length === 0) {
        return { x: 0, y: 0 };
      }
      let areaTerm = 0;
      let centroidX = 0;
      let centroidY = 0;
      for (let i = 0; i < points.length; i += 1) {
        const current = points[i];
        const next = points[(i + 1) % points.length];
        const cross = current.x * next.y - next.x * current.y;
        areaTerm += cross;
        centroidX += (current.x + next.x) * cross;
        centroidY += (current.y + next.y) * cross;
      }
      const area = areaTerm / 2;
      if (Math.abs(area) < 1e-5) {
        return { x: points[0].x, y: points[0].y };
      }
      const factor = 1 / (6 * area);
      return { x: centroidX * factor, y: centroidY * factor };
    }

    function getRoomPolygon(room) {
      if (!room) {
        return [];
      }
      if (Array.isArray(room.points) && room.points.length >= 3) {
        return room.points.map((point) => clonePoint(point)).filter(Boolean);
      }
      if (
        typeof room.x === "number" &&
        typeof room.y === "number" &&
        typeof room.width === "number" &&
        typeof room.height === "number"
      ) {
        return [
          { x: room.x, y: room.y },
          { x: room.x + room.width, y: room.y },
          { x: room.x + room.width, y: room.y + room.height },
          { x: room.x, y: room.y + room.height },
        ];
      }
      return [];
    }

    function resetRoomDraft() {
      roomDraftPoints = [];
      previewPoint = null;
      startPoint = null;
      if (drawingMode === "room") {
        isDrawing = false;
        drawingMode = null;
      }
    }

    function buildPlanPayload({ timestamp = null, includeExportMetadata = false } = {}) {
      const updatedTimestamp = timestamp || lastUpdatedAt || new Date().toISOString();
      const payload = {
        schema: "altinet-floorplan",
        version: 1,
        updatedAt: updatedTimestamp,
        gridSize,
        unitScale: defaultUnitScale,
        levels: levels.map((level, index) => ({
          index,
          id: level.id,
          name: level.name,
          walls: level.walls
            .map((wall) => {
              if (!wall) {
                return null;
              }
              const start = clonePoint(wall.start);
              const end = clonePoint(wall.end);
              if (!start || !end) {
                return null;
              }
              return { start, end };
            })
            .filter(Boolean),
          rooms: level.rooms.map((room) => {
            const polygon = getRoomPolygon(room);
            const points = polygon.length >= 3 ? polygon : undefined;
            return {
              name: room.name,
              points,
              x: typeof room.x === "number" ? room.x : undefined,
              y: typeof room.y === "number" ? room.y : undefined,
              width: typeof room.width === "number" ? room.width : undefined,
              height: typeof room.height === "number" ? room.height : undefined,
            };
          }),
        })),
        settings: { ...builderSettings },
      };
      if (includeExportMetadata) {
        payload.exportedAt = new Date().toISOString();
      }
      return payload;
    }

    function resetSyncTimer() {
      if (syncTimeoutId) {
        window.clearTimeout(syncTimeoutId);
      }
      syncTimeoutId = window.setTimeout(sendQueuedPayload, syncDelayMs);
    }

    function sendQueuedPayload() {
      if (!queuedPayload) {
        return;
      }
      const payload = queuedPayload;
      const payloadHash = queuedHash;
      queuedPayload = null;
      queuedHash = null;
      syncTimeoutId = null;
      inFlight = true;
      let succeeded = false;
      fetch(syncEndpoint, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-CSRFToken": getCsrfToken(),
        },
        credentials: "same-origin",
        body: JSON.stringify(payload),
      })
        .then((response) => {
          if (!response.ok) {
            throw new Error(`Sync failed with status ${response.status}`);
          }
          succeeded = true;
          lastSyncedHash = payloadHash;
        })
        .catch((error) => {
          console.warn("Could not sync floorplan to backend", error);
        })
        .finally(() => {
          inFlight = false;
          if (!succeeded && !queuedPayload) {
            queuedPayload = payload;
            queuedHash = payloadHash;
          }
          if (queuedPayload) {
            resetSyncTimer();
          }
        });
    }

    function scheduleSync(timestamp) {
      const payload = buildPlanPayload({ timestamp });
      const serialized = JSON.stringify(payload);
      if (serialized === lastSyncedHash || serialized === queuedHash) {
        return;
      }
      queuedPayload = JSON.parse(serialized);
      queuedHash = serialized;
      if (inFlight) {
        return;
      }
      resetSyncTimer();
    }

    function setActiveTool(tool) {
      activeTool = tool;
      toolButtons.forEach((button) => {
        if (button.dataset.tool === tool) {
          button.classList.add("active");
        } else {
          button.classList.remove("active");
        }
      });
      if (tool !== "wall") {
        clearSelectedWall();
        if (drawingMode === "wall") {
          isDrawing = false;
          drawingMode = null;
          startPoint = null;
          previewPoint = null;
        }
      }
      if (tool !== "room") {
        resetRoomDraft();
      }
      render();
    }

    toolButtons.forEach((button) => {
      button.addEventListener("click", () => setActiveTool(button.dataset.tool));
    });

    Object.entries(settingsInputs).forEach(([key, input]) => {
      if (!input) {
        return;
      }
      input.addEventListener("change", (event) => {
        const value = Number(event.target.value);
        if (Number.isFinite(value)) {
          updateSetting(key, value);
        } else {
          applySettingsToInputs();
        }
      });
    });

    function uuid() {
      if (typeof crypto !== "undefined" && crypto.randomUUID) {
        return crypto.randomUUID();
      }
      return `lvl-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
    }

    function createLevel(name) {
      return {
        id: uuid(),
        name,
        walls: [],
        rooms: [],
      };
    }

    function loadState() {
      try {
        const stored = localStorage.getItem(storageKey);
        if (!stored) {
          const initialLevel = createLevel("Level 1");
          levels = [initialLevel];
          activeLevelId = initialLevel.id;
          lastUpdatedAt = new Date().toISOString();
          builderSettings = { ...defaultSettings };
          applySettingsToInputs();
          needsInitialPersist = true;
          return;
        }
        const parsed = JSON.parse(stored);
        if (!Array.isArray(parsed.levels) || parsed.levels.length === 0) {
          throw new Error("Invalid stored plan");
        }
        builderSettings = normaliseSettings(parsed.settings);
        levels = parsed.levels.map((level, index) => {
          const walls = Array.isArray(level.walls)
            ? level.walls
                .map((wall) => {
                  if (!wall) {
                    return null;
                  }
                  const start = clonePoint(wall.start);
                  const end = clonePoint(wall.end);
                  if (!start || !end) {
                    return null;
                  }
                  return { start, end };
                })
                .filter(Boolean)
            : [];
          const rooms = Array.isArray(level.rooms)
            ? level.rooms.map((room, roomIndex) => {
                const polygon =
                  Array.isArray(room.points) && room.points.length >= 3
                    ? room.points.map((point) => clonePoint(point)).filter(Boolean)
                    : undefined;
                const bounds = polygon ? computePolygonBounds(polygon) : null;
                const width =
                  typeof room.width === "number"
                    ? room.width
                    : bounds
                    ? bounds.width
                    : 0;
                const height =
                  typeof room.height === "number"
                    ? room.height
                    : bounds
                    ? bounds.height
                    : 0;
                const x =
                  typeof room.x === "number" ? room.x : bounds ? bounds.x : 0;
                const y =
                  typeof room.y === "number" ? room.y : bounds ? bounds.y : 0;
                return {
                  name: (room.name || `Room ${roomIndex + 1}`).trim(),
                  points: polygon,
                  x,
                  y,
                  width,
                  height,
                };
              })
            : [];
          return {
            id: level.id || uuid(),
            name: level.name || `Level ${index + 1}`,
            walls,
            rooms,
          };
        });
        const storedActive = levels.find((level) => level.id === parsed.activeLevelId);
        activeLevelId = storedActive ? storedActive.id : levels[0].id;
        lastUpdatedAt =
          typeof parsed.updatedAt === "string" ? parsed.updatedAt : new Date().toISOString();
        needsInitialPersist = false;
        applySettingsToInputs();
      } catch (error) {
        console.warn("Could not load saved plan, resetting", error);
        const reset = createLevel("Level 1");
        levels = [reset];
        activeLevelId = reset.id;
        lastUpdatedAt = new Date().toISOString();
        needsInitialPersist = true;
        localStorage.removeItem(storageKey);
        builderSettings = { ...defaultSettings };
        applySettingsToInputs();
      }
    }

    function persistState() {
      const updatedAt = new Date().toISOString();
      lastUpdatedAt = updatedAt;
      const payload = {
        version: 1,
        updatedAt,
        activeLevelId,
        levels,
        settings: builderSettings,
      };
      localStorage.setItem(storageKey, JSON.stringify(payload));
      needsInitialPersist = false;
      scheduleSync(updatedAt);
    }

    function getActiveLevel() {
      return levels.find((level) => level.id === activeLevelId) || null;
    }

    function setActiveLevel(levelId, options = {}) {
      const { persist = true } = options;
      const level = levels.find((item) => item.id === levelId);
      if (!level) {
        return;
      }
      clearSelectedWall();
      resetRoomDraft();
      if (drawingMode === "wall") {
        isDrawing = false;
        drawingMode = null;
        startPoint = null;
        previewPoint = null;
      }
      activeLevelId = levelId;
      levelNameInput.value = level.name;
      activeLevelBadge.textContent = level.name;
      updateLevelTabs();
      updateRoomList();
      render();
      if (persist) {
        persistState();
      }
    }

    function updateLevelTabs() {
      levelTabs.innerHTML = "";
      levels.forEach((level) => {
        const button = document.createElement("button");
        button.type = "button";
        button.className = `btn btn-sm ${
          level.id === activeLevelId ? "btn-primary" : "btn-outline-light"
        }`;
        button.textContent = level.name;
        button.addEventListener("click", () => setActiveLevel(level.id));
        levelTabs.appendChild(button);
      });
      deleteLevelButton.disabled = levels.length <= 1;
    }

    function snapToGrid(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = (clientX - rect.left) * scaleX;
      const y = (clientY - rect.top) * scaleY;
      return {
        x: Math.round(x / gridSize) * gridSize,
        y: Math.round(y / gridSize) * gridSize,
      };
    }

    function getCanvasPoint(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = (clientX - rect.left) * scaleX;
      const y = (clientY - rect.top) * scaleY;
      return { x, y };
    }

    function distanceToSegment(point, start, end) {
      if (!start || !end) {
        return Number.POSITIVE_INFINITY;
      }
      const dx = end.x - start.x;
      const dy = end.y - start.y;
      if (dx === 0 && dy === 0) {
        return Math.hypot(point.x - start.x, point.y - start.y);
      }
      const t = Math.max(
        0,
        Math.min(1, ((point.x - start.x) * dx + (point.y - start.y) * dy) / (dx * dx + dy * dy)),
      );
      const projX = start.x + t * dx;
      const projY = start.y + t * dy;
      return Math.hypot(point.x - projX, point.y - projY);
    }

    function findWallNearPoint(point, threshold = 12) {
      const level = getActiveLevel();
      if (!level) {
        return null;
      }
      for (let index = level.walls.length - 1; index >= 0; index -= 1) {
        const wall = level.walls[index];
        if (!wall || !wall.start || !wall.end) {
          continue;
        }
        const distance = distanceToSegment(point, wall.start, wall.end);
        if (distance <= threshold) {
          return { wall, index };
        }
      }
      return null;
    }

    function getWallLengthMm(wall) {
      if (!wall || !wall.start || !wall.end) {
        return 0;
      }
      const dx = wall.end.x - wall.start.x;
      const dy = wall.end.y - wall.start.y;
      return Math.hypot(dx, dy) * mmPerPixel;
    }

    function getWallAngleDeg(wall) {
      if (!wall || !wall.start || !wall.end) {
        return 0;
      }
      let angleDeg = (Math.atan2(wall.end.y - wall.start.y, wall.end.x - wall.start.x) * 180) / Math.PI;
      if (angleDeg < 0) {
        angleDeg += 360;
      }
      return angleDeg;
    }

    function hideWallEditor() {
      if (!wallEditor) {
        return;
      }
      wallEditor.setAttribute("hidden", "");
    }

    function positionWallEditor(wall) {
      if (!wallEditor || !canvasContainer || wallEditor.hasAttribute("hidden")) {
        return;
      }
      const rect = canvas.getBoundingClientRect();
      const containerRect = canvasContainer.getBoundingClientRect();
      const scaleX = rect.width / canvas.width;
      const scaleY = rect.height / canvas.height;
      const midX = (wall.start.x + wall.end.x) / 2;
      const midY = (wall.start.y + wall.end.y) / 2;
      const left = midX * scaleX + (rect.left - containerRect.left);
      const top = midY * scaleY + (rect.top - containerRect.top);
      wallEditor.style.left = `${left}px`;
      wallEditor.style.top = `${top}px`;
      wallEditor.style.transform = "translate(-50%, -110%)";
      wallEditor.style.zIndex = "10";
    }

    function updateWallEditor(options = {}) {
      const { focusLength = false } = options;
      const level = getActiveLevel();
      if (
        selectedWallIndex === null ||
        !level ||
        !level.walls[selectedWallIndex] ||
        !level.walls[selectedWallIndex].start ||
        !level.walls[selectedWallIndex].end
      ) {
        hideWallEditor();
        return;
      }
      const wall = level.walls[selectedWallIndex];
      const lengthMm = getWallLengthMm(wall);
      if (wallLengthInput && Number.isFinite(lengthMm)) {
        wallLengthInput.value = Math.max(0, Math.round(lengthMm));
      }
      const angleDeg = getWallAngleDeg(wall);
      if (wallAngleInput && Number.isFinite(angleDeg)) {
        wallAngleInput.value = Math.round(angleDeg * 10) / 10;
      }
      wallEditor.removeAttribute("hidden");
      positionWallEditor(wall);
      if (focusLength && wallLengthInput) {
        wallLengthInput.focus();
        wallLengthInput.select();
      }
    }

    function clearSelectedWall() {
      selectedWallIndex = null;
      hideWallEditor();
    }

    function selectWall(index, options = {}) {
      const level = getActiveLevel();
      if (!level || index < 0 || index >= level.walls.length) {
        clearSelectedWall();
        render();
        return;
      }
      selectedWallIndex = index;
      render();
      updateWallEditor(options);
    }

    function updateSelectedWallGeometry({ lengthMm = null, angleDeg = null } = {}) {
      const level = getActiveLevel();
      if (
        selectedWallIndex === null ||
        !level ||
        !level.walls[selectedWallIndex] ||
        !level.walls[selectedWallIndex].start ||
        !level.walls[selectedWallIndex].end
      ) {
        return;
      }
      const wall = level.walls[selectedWallIndex];
      const currentLength = getWallLengthMm(wall);
      const newLengthMm = lengthMm !== null ? lengthMm : currentLength;
      if (!Number.isFinite(newLengthMm) || newLengthMm <= 0) {
        return;
      }
      const currentAngle = getWallAngleDeg(wall);
      const desiredAngleDeg =
        angleDeg !== null && Number.isFinite(angleDeg) ? ((angleDeg % 360) + 360) % 360 : currentAngle;
      const angleRad = (desiredAngleDeg * Math.PI) / 180;
      const lengthPx = newLengthMm / mmPerPixel;
      const endX = wall.start.x + Math.cos(angleRad) * lengthPx;
      const endY = wall.start.y + Math.sin(angleRad) * lengthPx;
      wall.end = { x: endX, y: endY };
      persistState();
      render();
      updateWallEditor();
    }

    function handleWallRemoval(removedIndex) {
      const level = getActiveLevel();
      if (selectedWallIndex === null) {
        return;
      }
      if (!level || level.walls.length === 0) {
        clearSelectedWall();
        return;
      }
      if (selectedWallIndex > removedIndex) {
        selectedWallIndex -= 1;
      } else if (selectedWallIndex === removedIndex && selectedWallIndex >= level.walls.length) {
        selectedWallIndex = level.walls.length - 1;
      }
      if (selectedWallIndex < 0 || selectedWallIndex >= level.walls.length) {
        clearSelectedWall();
      }
    }

    function drawGrid() {
      ctx.save();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = "#e9ecef";
      ctx.lineWidth = 1;
      for (let x = 0; x <= canvas.width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x + 0.5, 0);
        ctx.lineTo(x + 0.5, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y <= canvas.height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y + 0.5);
        ctx.lineTo(canvas.width, y + 0.5);
        ctx.stroke();
      }
      ctx.restore();
    }

    function renderRooms() {
      ctx.save();
      const level = getActiveLevel();
      if (!level) {
        ctx.restore();
        return;
      }
      ctx.lineWidth = 2;
      ctx.font = "14px sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      level.rooms.forEach((room) => {
        const polygon = getRoomPolygon(room);
        if (polygon.length < 3) {
          return;
        }
        ctx.beginPath();
        ctx.moveTo(polygon[0].x, polygon[0].y);
        for (let i = 1; i < polygon.length; i += 1) {
          ctx.lineTo(polygon[i].x, polygon[i].y);
        }
        ctx.closePath();
        ctx.fillStyle = "rgba(25, 135, 84, 0.15)";
        ctx.strokeStyle = "rgba(25, 135, 84, 0.7)";
        ctx.fill();
        ctx.stroke();
        const centroid = getPolygonCentroid(polygon);
        ctx.fillStyle = "#198754";
        ctx.fillText(room.name, centroid.x, centroid.y);
      });
      ctx.restore();
    }

    function renderWalls() {
      ctx.save();
      ctx.lineWidth = 4;
      ctx.lineCap = "round";
      const level = getActiveLevel();
      if (!level) {
        ctx.restore();
        return;
      }
      level.walls.forEach((wall, index) => {
        if (!wall || !wall.start || !wall.end) {
          return;
        }
        ctx.beginPath();
        ctx.strokeStyle =
          index === selectedWallIndex ? "rgba(13, 110, 253, 0.9)" : "rgba(52, 58, 64, 0.45)";
        ctx.moveTo(wall.start.x, wall.start.y);
        ctx.lineTo(wall.end.x, wall.end.y);
        ctx.stroke();
        if (index === selectedWallIndex) {
          ctx.fillStyle = "rgba(13, 110, 253, 0.9)";
          [wall.start, wall.end].forEach((point) => {
            ctx.beginPath();
            ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
            ctx.fill();
          });
        }
      });
      ctx.restore();
    }

    function renderPreview() {
      if (!isDrawing) {
        return;
      }
      ctx.save();
      if (drawingMode === "wall" && startPoint && previewPoint) {
        ctx.strokeStyle = "rgba(13, 110, 253, 0.8)";
        ctx.lineWidth = 4;
        ctx.setLineDash([8, 6]);
        ctx.beginPath();
        ctx.moveTo(startPoint.x, startPoint.y);
        ctx.lineTo(previewPoint.x, previewPoint.y);
        ctx.stroke();
      } else if (drawingMode === "room" && roomDraftPoints.length) {
        const previewVertices = roomDraftPoints.map((point) => ({ x: point.x, y: point.y }));
        if (previewPoint) {
          previewVertices.push({ x: previewPoint.x, y: previewPoint.y });
        }
        if (previewVertices.length >= 2) {
          ctx.strokeStyle = "rgba(25, 135, 84, 0.85)";
          ctx.fillStyle = "rgba(25, 135, 84, 0.18)";
          ctx.lineWidth = 2;
          ctx.setLineDash([10, 6]);
          ctx.beginPath();
          ctx.moveTo(previewVertices[0].x, previewVertices[0].y);
          for (let i = 1; i < previewVertices.length; i += 1) {
            ctx.lineTo(previewVertices[i].x, previewVertices[i].y);
          }
          if (previewVertices.length >= 3) {
            ctx.closePath();
            ctx.fill();
          }
          ctx.stroke();
          ctx.setLineDash([]);
        }
        const first = roomDraftPoints[0];
        ctx.fillStyle = "rgba(25, 135, 84, 0.9)";
        ctx.beginPath();
        ctx.arc(first.x, first.y, 5, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }

    function render() {
      drawGrid();
      renderRooms();
      renderWalls();
      renderPreview();
      if (selectedWallIndex !== null) {
        const level = getActiveLevel();
        if (level && level.walls[selectedWallIndex]) {
          positionWallEditor(level.walls[selectedWallIndex]);
        }
      }
    }

    function updateRoomList() {
      roomList.innerHTML = "";
      const level = getActiveLevel();
      if (!level || level.rooms.length === 0) {
        const empty = document.createElement("li");
        empty.className = "list-group-item text-muted";
        empty.textContent = "Draw a room on the active level to see it listed here.";
        roomList.appendChild(empty);
        return;
      }

      level.rooms.forEach((room, index) => {
        const li = document.createElement("li");
        li.className = "list-group-item d-flex justify-content-between align-items-center";
        const polygon = getRoomPolygon(room);
        const bounds = polygon.length
          ? computePolygonBounds(polygon)
          : {
              x: typeof room.x === "number" ? room.x : 0,
              y: typeof room.y === "number" ? room.y : 0,
              width: typeof room.width === "number" ? room.width : 0,
              height: typeof room.height === "number" ? room.height : 0,
            };
        const widthUnits = Math.round((bounds.width / gridSize) * 100) / 100;
        const heightUnits = Math.round((bounds.height / gridSize) * 100) / 100;
        const details = [];
        if (polygon.length >= 3) {
          const areaPx = calculatePolygonArea(polygon);
          const areaSqM = areaPx * metersPerPixel * metersPerPixel;
          if (Number.isFinite(areaSqM) && areaSqM > 0) {
            const roundedArea = Math.round(areaSqM * 100) / 100;
            details.push(`${roundedArea.toFixed(2)} m²`);
          }
        }
        details.push(`${widthUnits} × ${heightUnits} grid units`);
        li.innerHTML = `<span><strong>${room.name}</strong></span><span class="text-muted">${details.join(" · ")}</span>`;
        li.dataset.index = index;
        roomList.appendChild(li);
      });
    }

    function handlePointerDown(event) {
      if (event.preventDefault) {
        event.preventDefault();
      }
      const clientX = event.clientX;
      const clientY = event.clientY;

      if (activeTool === "wall") {
        const canvasPoint = getCanvasPoint(clientX, clientY);
        const hit = findWallNearPoint(canvasPoint);
        if (hit) {
          isDrawing = false;
          drawingMode = null;
          startPoint = null;
          previewPoint = null;
          selectWall(hit.index);
          return;
        }
        clearSelectedWall();
        isDrawing = true;
        drawingMode = "wall";
        startPoint = snapToGrid(clientX, clientY);
        previewPoint = { ...startPoint };
        render();
        return;
      }

      if (activeTool === "room") {
        clearSelectedWall();
        const snapped = snapToGrid(clientX, clientY);
        if (!isDrawing || drawingMode !== "room" || roomDraftPoints.length === 0) {
          roomDraftPoints = [snapped];
          isDrawing = true;
          drawingMode = "room";
          previewPoint = { ...snapped };
          render();
          return;
        }

        const firstPoint = roomDraftPoints[0];
        if (
          roomDraftPoints.length >= 3 &&
          (arePointsEqual(snapped, firstPoint) || distanceBetweenPoints(snapped, firstPoint) <= roomClosureThreshold)
        ) {
          const finished = finalizeRoomDraft();
          if (finished) {
            resetRoomDraft();
            render();
          }
          return;
        }

        const lastPoint = roomDraftPoints[roomDraftPoints.length - 1];
        if (!arePointsEqual(lastPoint, snapped)) {
          roomDraftPoints.push(snapped);
        }
        previewPoint = { ...snapped };
        render();
      }
    }

    function handlePointerMove(event) {
      if (!isDrawing) {
        return;
      }
      if (drawingMode === "wall" || drawingMode === "room") {
        previewPoint = snapToGrid(event.clientX, event.clientY);
        render();
      }
    }

    function createWall(endPoint) {
      const start = clonePoint(startPoint);
      const end = clonePoint(endPoint);
      if (!start || !end || (start.x === end.x && start.y === end.y)) {
        return;
      }
      const level = getActiveLevel();
      if (!level) {
        return;
      }
      level.walls.push({ start, end });
      persistState();
      selectWall(level.walls.length - 1, { focusLength: true });
    }

    function finalizeRoomDraft() {
      if (roomDraftPoints.length < 3) {
        return false;
      }
      const level = getActiveLevel();
      if (!level) {
        return false;
      }
      const polygon = roomDraftPoints.map((point) => ({ x: point.x, y: point.y }));
      const defaultName = `Room ${level.rooms.length + 1}`;
      const enteredName = window.prompt("Name this room", defaultName);
      if (enteredName === null) {
        return false;
      }
      const name = enteredName.trim() || defaultName;
      const bounds = computePolygonBounds(polygon);
      level.rooms.push({
        name,
        points: polygon,
        x: bounds.x,
        y: bounds.y,
        width: bounds.width,
        height: bounds.height,
      });
      updateRoomList();
      persistState();
      return true;
    }

    function handlePointerUp(event) {
      if (!isDrawing || drawingMode !== "wall") {
        return;
      }
      const endPoint = snapToGrid(event.clientX, event.clientY);
      createWall(endPoint);
      isDrawing = false;
      drawingMode = null;
      startPoint = null;
      previewPoint = null;
      render();
    }

    function handlePointerLeave() {
      if (!isDrawing) {
        return;
      }
      if (drawingMode === "wall") {
        isDrawing = false;
        drawingMode = null;
        startPoint = null;
        previewPoint = null;
        render();
      } else if (drawingMode === "room") {
        previewPoint = null;
        render();
      }
    }

    canvas.addEventListener("mousedown", handlePointerDown);
    canvas.addEventListener("mousemove", handlePointerMove);
    canvas.addEventListener("mouseup", handlePointerUp);
    canvas.addEventListener("mouseleave", handlePointerLeave);
    canvas.addEventListener("dblclick", (event) => {
      if (event.preventDefault) {
        event.preventDefault();
      }
      if (activeTool !== "room" || drawingMode !== "room") {
        return;
      }
      if (roomDraftPoints.length < 3) {
        return;
      }
      const finished = finalizeRoomDraft();
      if (finished) {
        resetRoomDraft();
        render();
      }
    });

    canvas.addEventListener("touchstart", (event) => {
      const touch = event.touches[0];
      if (!touch) {
        return;
      }
      event.preventDefault();
      handlePointerDown(touch);
    });
    canvas.addEventListener("touchmove", (event) => {
      const touch = event.touches[0];
      if (!touch) {
        return;
      }
      event.preventDefault();
      handlePointerMove(touch);
    });
    canvas.addEventListener("touchend", (event) => {
      const touch = event.changedTouches[0];
      if (!touch) {
        return;
      }
      event.preventDefault();
      handlePointerUp(touch);
    });
    canvas.addEventListener("touchcancel", () => {
      handlePointerLeave();
    });

    if (wallLengthInput) {
      wallLengthInput.addEventListener("change", () => {
        const value = parseFloat(wallLengthInput.value);
        if (Number.isFinite(value) && value > 0) {
          updateSelectedWallGeometry({ lengthMm: value });
        } else {
          updateWallEditor();
        }
      });
    }

    if (wallAngleInput) {
      wallAngleInput.addEventListener("change", () => {
        const value = parseFloat(wallAngleInput.value);
        if (Number.isFinite(value)) {
          updateSelectedWallGeometry({ angleDeg: value });
        } else {
          updateWallEditor();
        }
      });
    }

    if (deleteWallButton) {
      deleteWallButton.addEventListener("click", () => {
        const level = getActiveLevel();
        if (selectedWallIndex === null || !level) {
          return;
        }
        const previousIndex = selectedWallIndex;
        level.walls.splice(previousIndex, 1);
        persistState();
        if (level.walls.length > 0) {
          const nextIndex = Math.min(previousIndex, level.walls.length - 1);
          selectWall(nextIndex);
        } else {
          clearSelectedWall();
          render();
        }
      });
    }

    if (closeWallEditorButton) {
      closeWallEditorButton.addEventListener("click", () => {
        clearSelectedWall();
        render();
      });
    }

    clearButton.addEventListener("click", () => {
      const level = getActiveLevel();
      if (!level) {
        return;
      }
      clearSelectedWall();
      resetRoomDraft();
      if (drawingMode === "wall") {
        isDrawing = false;
        drawingMode = null;
        startPoint = null;
        previewPoint = null;
      }
      level.walls.length = 0;
      level.rooms.length = 0;
      updateRoomList();
      render();
      persistState();
    });

    undoButton.addEventListener("click", () => {
      const level = getActiveLevel();
      if (!level) {
        return;
      }
      if (drawingMode === "wall" && isDrawing) {
        isDrawing = false;
        drawingMode = null;
        startPoint = null;
        previewPoint = null;
        render();
        return;
      }
      if (activeTool === "room" && drawingMode === "room" && roomDraftPoints.length > 0) {
        roomDraftPoints.pop();
        if (roomDraftPoints.length === 0) {
          resetRoomDraft();
        } else {
          const lastPoint = roomDraftPoints[roomDraftPoints.length - 1];
          previewPoint = { ...lastPoint };
        }
        render();
        return;
      }
      let changed = false;
      if (activeTool === "wall" && level.walls.length) {
        const removedIndex = level.walls.length - 1;
        level.walls.pop();
        handleWallRemoval(removedIndex);
        changed = true;
      } else if (activeTool === "room" && level.rooms.length) {
        level.rooms.pop();
        updateRoomList();
        changed = true;
      } else if (level.walls.length) {
        const removedIndex = level.walls.length - 1;
        level.walls.pop();
        handleWallRemoval(removedIndex);
        changed = true;
      } else if (level.rooms.length) {
        level.rooms.pop();
        updateRoomList();
        changed = true;
      }
      if (changed) {
        render();
        if (selectedWallIndex !== null) {
          updateWallEditor();
        } else {
          hideWallEditor();
        }
        persistState();
      }
    });

    window.addEventListener("resize", render);

    window.addEventListener("resize", () => {
      if (selectedWallIndex !== null) {
        updateWallEditor();
      }
    });

    loadState();
    updateLevelTabs();
    setActiveLevel(activeLevelId, { persist: false });
    updateRoomList();
    render();

    if (needsInitialPersist) {
      persistState();
    } else if (lastUpdatedAt) {
      scheduleSync(lastUpdatedAt);
    }

    levelNameInput.addEventListener("input", (event) => {
      const level = getActiveLevel();
      if (!level) {
        return;
      }
      const value = event.target.value.trim() || "Unnamed level";
      level.name = value;
      activeLevelBadge.textContent = value;
      updateLevelTabs();
      persistState();
    });

    addLevelButton.addEventListener("click", () => {
      const newLevelIndex = levels.length + 1;
      const level = createLevel(`Level ${newLevelIndex}`);
      levels.push(level);
      persistState();
      updateLevelTabs();
      setActiveLevel(level.id);
    });

    duplicateLevelButton.addEventListener("click", () => {
      const active = getActiveLevel();
      if (!active) {
        return;
      }
      const clone = {
        id: uuid(),
        name: `${active.name} copy`,
        walls: active.walls
          .map((wall) => {
            const start = clonePoint(wall.start);
            const end = clonePoint(wall.end);
            if (!start || !end) {
              return null;
            }
            return { start, end };
          })
          .filter(Boolean),
        rooms: active.rooms.map((room) => {
          const points =
            Array.isArray(room.points) && room.points.length >= 3
              ? room.points.map((point) => clonePoint(point)).filter(Boolean)
              : undefined;
          return {
            name: room.name,
            points,
            x: room.x,
            y: room.y,
            width: room.width,
            height: room.height,
          };
        }),
      };
      levels.push(clone);
      persistState();
      updateLevelTabs();
      setActiveLevel(clone.id);
    });

    deleteLevelButton.addEventListener("click", () => {
      if (levels.length <= 1) {
        return;
      }
      const confirmation = window.confirm(
        "Delete the current level? This cannot be undone and removes its rooms and walls.",
      );
      if (!confirmation) {
        return;
      }
      levels = levels.filter((level) => level.id !== activeLevelId);
      activeLevelId = levels[0].id;
      persistState();
      updateLevelTabs();
      setActiveLevel(activeLevelId);
    });

    exportPlanButton.addEventListener("click", () => {
      const exportData = buildPlanPayload({
        includeExportMetadata: true,
        timestamp: lastUpdatedAt || new Date().toISOString(),
      });
      const blob = new Blob([JSON.stringify(exportData, null, 2)], {
        type: "application/json",
      });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = `altinet-floorplan-${Date.now()}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    });
  })();
</script>
{% endblock %}
