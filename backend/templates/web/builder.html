{% extends "web/base.html" %}

{% block title %}Builder | Altinet{% endblock %}

{% block content %}
<div class="row g-4">
  <div class="col-12 col-lg-8">
    <div class="card shadow-sm h-100">
      <div class="card-header bg-dark text-white d-flex flex-column flex-xl-row gap-3 align-items-start align-items-xl-center justify-content-between">
        <div>
          <div class="d-flex align-items-center gap-2">
            <span class="fw-semibold">Floorplan Builder</span>
            <span class="badge text-bg-secondary" id="activeLevelLabel">Level 1</span>
          </div>
          <p class="small mb-0 text-white-50">
            Switch between levels to sketch multi-storey layouts. Changes are saved locally in your browser.
          </p>
        </div>
        <div class="d-flex flex-wrap gap-2">
          <div class="btn-group" role="group" aria-label="Levels" id="levelTabs"></div>
          <button type="button" class="btn btn-outline-light btn-sm" id="addLevel">
            Add level
          </button>
        </div>
      </div>
      <div class="card-body">
        <div class="d-flex flex-column flex-md-row justify-content-between align-items-start align-items-md-center gap-3 mb-3">
          <div class="btn-group" role="group" aria-label="Builder tools">
            <button type="button" class="btn btn-outline-primary active" data-tool="wall">
              Wall tool
            </button>
            <button type="button" class="btn btn-outline-primary" data-tool="room">
              Room tool
            </button>
          </div>
          <div class="d-flex gap-2">
            <button type="button" class="btn btn-outline-secondary" id="undoLast">
              Undo last
            </button>
            <button type="button" class="btn btn-outline-danger" id="clearCanvas">
              Clear level
            </button>
          </div>
        </div>
        <div class="border rounded position-relative overflow-hidden">
          <canvas
            id="builderCanvas"
            width="900"
            height="600"
            class="w-100 h-auto"
          ></canvas>
        </div>
        <div class="d-flex flex-column flex-lg-row gap-3 mt-3">
          <div class="flex-grow-1">
            <label for="levelName" class="form-label small text-uppercase fw-semibold text-secondary">
              Active level name
            </label>
            <input type="text" class="form-control" id="levelName" placeholder="e.g. Ground floor" maxlength="40" />
          </div>
          <div class="flex-shrink-0 d-flex flex-column gap-2">
            <button type="button" class="btn btn-outline-secondary" id="duplicateLevel">
              Duplicate level
            </button>
            <button type="button" class="btn btn-outline-danger" id="deleteLevel">
              Delete level
            </button>
          </div>
        </div>
        <div class="alert alert-info mt-3 mb-0" role="alert">
          <h2 class="h6 fw-semibold mb-2">Workflow</h2>
          <ol class="mb-0 small ps-3">
            <li>Sketch each storey of the property using the tools above and switch levels as needed.</li>
            <li>Your changes sync to the backend automatically, triggering a fresh 3D model build for the dashboard viewer.</li>
            <li>Use the export button if you still need a JSON copy for external tools or manual Blender tweaks.</li>
          </ol>
        </div>
      </div>
    </div>
  </div>
  <div class="col-12 col-lg-4">
    <div class="card shadow-sm h-100">
      <div class="card-header bg-dark text-white">Rooms</div>
      <div class="card-body d-flex flex-column">
        <p class="text-muted small">
          Rooms you define are listed here with their grid dimensions. Use this as a quick reference while sketching your layout.
        </p>
        <ul class="list-group flex-grow-1" id="roomList"></ul>
        <div class="mt-3">
          <button type="button" class="btn btn-primary w-100" id="exportPlan">Export plan for Blender</button>
          <p class="small text-muted mt-2 mb-0">
            Need an offline copy? Export to <code>.json</code> for Blender or archiving &mdash; the backend already rebuilds the OBJ automatically.
          </p>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  (function () {
    const canvas = document.getElementById("builderCanvas");
    const ctx = canvas.getContext("2d");
    const gridSize = 30;
    const storageKey = "altinet-floorplan";
    const defaultUnitScale = 0.5; // metres per grid unit
    const syncEndpoint = "/api/floorplans/render/";
    const syncDelayMs = 1500;
    let lastUpdatedAt = null;
    let syncTimeoutId = null;
    let queuedPayload = null;
    let queuedHash = null;
    let inFlight = false;
    let lastSyncedHash = null;
    let levels = [];
    let activeLevelId = null;
    let needsInitialPersist = false;
    let isDrawing = false;
    let startPoint = null;
    let previewPoint = null;
    let activeTool = "wall";

    const toolButtons = document.querySelectorAll("[data-tool]");
    const roomList = document.getElementById("roomList");
    const clearButton = document.getElementById("clearCanvas");
    const undoButton = document.getElementById("undoLast");
    const levelTabs = document.getElementById("levelTabs");
    const levelNameInput = document.getElementById("levelName");
    const addLevelButton = document.getElementById("addLevel");
    const duplicateLevelButton = document.getElementById("duplicateLevel");
    const deleteLevelButton = document.getElementById("deleteLevel");
    const exportPlanButton = document.getElementById("exportPlan");
    const activeLevelBadge = document.getElementById("activeLevelLabel");

    function getCsrfToken() {
      const name = "csrftoken=";
      const cookies = document.cookie ? document.cookie.split(";") : [];
      for (const cookie of cookies) {
        const trimmed = cookie.trim();
        if (trimmed.startsWith(name)) {
          return decodeURIComponent(trimmed.slice(name.length));
        }
      }
      return "";
    }

    function buildPlanPayload({ timestamp = null, includeExportMetadata = false } = {}) {
      const updatedTimestamp = timestamp || lastUpdatedAt || new Date().toISOString();
      const payload = {
        schema: "altinet-floorplan",
        version: 1,
        updatedAt: updatedTimestamp,
        gridSize,
        unitScale: defaultUnitScale,
        levels: levels.map((level, index) => ({
          index,
          id: level.id,
          name: level.name,
          walls: level.walls,
          rooms: level.rooms,
        })),
      };
      if (includeExportMetadata) {
        payload.exportedAt = new Date().toISOString();
      }
      return payload;
    }

    function resetSyncTimer() {
      if (syncTimeoutId) {
        window.clearTimeout(syncTimeoutId);
      }
      syncTimeoutId = window.setTimeout(sendQueuedPayload, syncDelayMs);
    }

    function sendQueuedPayload() {
      if (!queuedPayload) {
        return;
      }
      const payload = queuedPayload;
      const payloadHash = queuedHash;
      queuedPayload = null;
      queuedHash = null;
      syncTimeoutId = null;
      inFlight = true;
      let succeeded = false;
      fetch(syncEndpoint, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-CSRFToken": getCsrfToken(),
        },
        credentials: "same-origin",
        body: JSON.stringify(payload),
      })
        .then((response) => {
          if (!response.ok) {
            throw new Error(`Sync failed with status ${response.status}`);
          }
          succeeded = true;
          lastSyncedHash = payloadHash;
        })
        .catch((error) => {
          console.warn("Could not sync floorplan to backend", error);
        })
        .finally(() => {
          inFlight = false;
          if (!succeeded && !queuedPayload) {
            queuedPayload = payload;
            queuedHash = payloadHash;
          }
          if (queuedPayload) {
            resetSyncTimer();
          }
        });
    }

    function scheduleSync(timestamp) {
      const payload = buildPlanPayload({ timestamp });
      const serialized = JSON.stringify(payload);
      if (serialized === lastSyncedHash || serialized === queuedHash) {
        return;
      }
      queuedPayload = JSON.parse(serialized);
      queuedHash = serialized;
      if (inFlight) {
        return;
      }
      resetSyncTimer();
    }

    function setActiveTool(tool) {
      activeTool = tool;
      toolButtons.forEach((button) => {
        if (button.dataset.tool === tool) {
          button.classList.add("active");
        } else {
          button.classList.remove("active");
        }
      });
    }

    toolButtons.forEach((button) => {
      button.addEventListener("click", () => setActiveTool(button.dataset.tool));
    });

    function uuid() {
      if (typeof crypto !== "undefined" && crypto.randomUUID) {
        return crypto.randomUUID();
      }
      return `lvl-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
    }

    function createLevel(name) {
      return {
        id: uuid(),
        name,
        walls: [],
        rooms: [],
      };
    }

    function loadState() {
      try {
        const stored = localStorage.getItem(storageKey);
        if (!stored) {
          const initialLevel = createLevel("Level 1");
          levels = [initialLevel];
          activeLevelId = initialLevel.id;
          lastUpdatedAt = new Date().toISOString();
          needsInitialPersist = true;
          return;
        }
        const parsed = JSON.parse(stored);
        if (!Array.isArray(parsed.levels) || parsed.levels.length === 0) {
          throw new Error("Invalid stored plan");
        }
        levels = parsed.levels.map((level, index) => ({
          id: level.id || uuid(),
          name: level.name || `Level ${index + 1}`,
          walls: Array.isArray(level.walls) ? level.walls : [],
          rooms: Array.isArray(level.rooms) ? level.rooms : [],
        }));
        const storedActive = levels.find((level) => level.id === parsed.activeLevelId);
        activeLevelId = storedActive ? storedActive.id : levels[0].id;
        lastUpdatedAt =
          typeof parsed.updatedAt === "string" ? parsed.updatedAt : new Date().toISOString();
        needsInitialPersist = false;
      } catch (error) {
        console.warn("Could not load saved plan, resetting", error);
        const reset = createLevel("Level 1");
        levels = [reset];
        activeLevelId = reset.id;
        lastUpdatedAt = new Date().toISOString();
        needsInitialPersist = true;
        localStorage.removeItem(storageKey);
      }
    }

    function persistState() {
      const updatedAt = new Date().toISOString();
      lastUpdatedAt = updatedAt;
      const payload = {
        version: 1,
        updatedAt,
        activeLevelId,
        levels,
      };
      localStorage.setItem(storageKey, JSON.stringify(payload));
      needsInitialPersist = false;
      scheduleSync(updatedAt);
    }

    function getActiveLevel() {
      return levels.find((level) => level.id === activeLevelId) || null;
    }

    function setActiveLevel(levelId, options = {}) {
      const { persist = true } = options;
      const level = levels.find((item) => item.id === levelId);
      if (!level) {
        return;
      }
      activeLevelId = levelId;
      levelNameInput.value = level.name;
      activeLevelBadge.textContent = level.name;
      updateLevelTabs();
      updateRoomList();
      render();
      if (persist) {
        persistState();
      }
    }

    function updateLevelTabs() {
      levelTabs.innerHTML = "";
      levels.forEach((level) => {
        const button = document.createElement("button");
        button.type = "button";
        button.className = `btn btn-sm ${
          level.id === activeLevelId ? "btn-primary" : "btn-outline-light"
        }`;
        button.textContent = level.name;
        button.addEventListener("click", () => setActiveLevel(level.id));
        levelTabs.appendChild(button);
      });
      deleteLevelButton.disabled = levels.length <= 1;
    }

    function snapToGrid(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = (clientX - rect.left) * scaleX;
      const y = (clientY - rect.top) * scaleY;
      return {
        x: Math.round(x / gridSize) * gridSize,
        y: Math.round(y / gridSize) * gridSize,
      };
    }

    function drawGrid() {
      ctx.save();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = "#e9ecef";
      ctx.lineWidth = 1;
      for (let x = 0; x <= canvas.width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x + 0.5, 0);
        ctx.lineTo(x + 0.5, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y <= canvas.height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y + 0.5);
        ctx.lineTo(canvas.width, y + 0.5);
        ctx.stroke();
      }
      ctx.restore();
    }

    function renderRooms() {
      ctx.save();
      const level = getActiveLevel();
      if (!level) {
        ctx.restore();
        return;
      }
      level.rooms.forEach((room) => {
        ctx.fillStyle = "rgba(13, 110, 253, 0.15)";
        ctx.strokeStyle = "rgba(13, 110, 253, 0.6)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.rect(room.x, room.y, room.width, room.height);
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = "#0d6efd";
        ctx.font = "14px sans-serif";
        ctx.fillText(room.name, room.x + 10, room.y + 20);
      });
      ctx.restore();
    }

    function renderWalls() {
      ctx.save();
      ctx.strokeStyle = "#343a40";
      ctx.lineWidth = 4;
      ctx.lineCap = "round";
      const level = getActiveLevel();
      if (!level) {
        ctx.restore();
        return;
      }
      level.walls.forEach((wall) => {
        ctx.beginPath();
        ctx.moveTo(wall.start.x, wall.start.y);
        ctx.lineTo(wall.end.x, wall.end.y);
        ctx.stroke();
      });
      ctx.restore();
    }

    function renderPreview() {
      if (!isDrawing || !startPoint || !previewPoint) {
        return;
      }
      ctx.save();
      if (activeTool === "wall") {
        ctx.strokeStyle = "rgba(13, 110, 253, 0.8)";
        ctx.lineWidth = 4;
        ctx.setLineDash([8, 6]);
        ctx.beginPath();
        ctx.moveTo(startPoint.x, startPoint.y);
        ctx.lineTo(previewPoint.x, previewPoint.y);
        ctx.stroke();
      } else if (activeTool === "room") {
        const width = previewPoint.x - startPoint.x;
        const height = previewPoint.y - startPoint.y;
        if (width !== 0 && height !== 0) {
          ctx.fillStyle = "rgba(25, 135, 84, 0.2)";
          ctx.strokeStyle = "rgba(25, 135, 84, 0.8)";
          ctx.setLineDash([10, 8]);
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.rect(startPoint.x, startPoint.y, width, height);
          ctx.fill();
          ctx.stroke();
        }
      }
      ctx.restore();
    }

    function render() {
      drawGrid();
      renderRooms();
      renderWalls();
      renderPreview();
    }

    function updateRoomList() {
      roomList.innerHTML = "";
      const level = getActiveLevel();
      if (!level || level.rooms.length === 0) {
        const empty = document.createElement("li");
        empty.className = "list-group-item text-muted";
        empty.textContent = "Draw a room on the active level to see it listed here.";
        roomList.appendChild(empty);
        return;
      }

      level.rooms.forEach((room, index) => {
        const li = document.createElement("li");
        li.className = "list-group-item d-flex justify-content-between align-items-center";
        const widthUnits = Math.round((room.width / gridSize) * 100) / 100;
        const heightUnits = Math.round((room.height / gridSize) * 100) / 100;
        li.innerHTML = `<span><strong>${room.name}</strong></span><span class="text-muted">${widthUnits} × ${heightUnits} grid units</span>`;
        li.dataset.index = index;
        roomList.appendChild(li);
      });
    }

    function handlePointerDown(event) {
      event.preventDefault();
      isDrawing = true;
      startPoint = snapToGrid(event.clientX, event.clientY);
      previewPoint = { ...startPoint };
      render();
    }

    function handlePointerMove(event) {
      if (!isDrawing) {
        return;
      }
      previewPoint = snapToGrid(event.clientX, event.clientY);
      render();
    }

    function createWall(endPoint) {
      if (!startPoint || (startPoint.x === endPoint.x && startPoint.y === endPoint.y)) {
        return;
      }
      const level = getActiveLevel();
      if (!level) {
        return;
      }
      level.walls.push({ start: { ...startPoint }, end: { ...endPoint } });
      persistState();
    }

    function createRoom(endPoint) {
      if (!startPoint || startPoint.x === endPoint.x || startPoint.y === endPoint.y) {
        return;
      }
      const level = getActiveLevel();
      if (!level) {
        return;
      }
      const x = Math.min(startPoint.x, endPoint.x);
      const y = Math.min(startPoint.y, endPoint.y);
      const width = Math.abs(endPoint.x - startPoint.x);
      const height = Math.abs(endPoint.y - startPoint.y);
      const defaultName = `Room ${level.rooms.length + 1}`;
      const enteredName = window.prompt("Name this room", defaultName);
      if (enteredName === null) {
        return;
      }
      const name = enteredName.trim() || defaultName;
      level.rooms.push({ name, x, y, width, height });
      updateRoomList();
      persistState();
    }

    function handlePointerUp(event) {
      if (!isDrawing) {
        return;
      }
      const endPoint = snapToGrid(event.clientX, event.clientY);
      if (activeTool === "wall") {
        createWall(endPoint);
      } else {
        createRoom(endPoint);
      }
      isDrawing = false;
      startPoint = null;
      previewPoint = null;
      render();
    }

    function handlePointerLeave() {
      if (isDrawing) {
        isDrawing = false;
        startPoint = null;
        previewPoint = null;
        render();
      }
    }

    canvas.addEventListener("mousedown", handlePointerDown);
    canvas.addEventListener("mousemove", handlePointerMove);
    canvas.addEventListener("mouseup", handlePointerUp);
    canvas.addEventListener("mouseleave", handlePointerLeave);

    canvas.addEventListener("touchstart", (event) => {
      const touch = event.touches[0];
      handlePointerDown(touch);
    });
    canvas.addEventListener("touchmove", (event) => {
      const touch = event.touches[0];
      handlePointerMove(touch);
    });
    canvas.addEventListener("touchend", (event) => {
      const touch = event.changedTouches[0];
      handlePointerUp(touch);
    });
    canvas.addEventListener("touchcancel", handlePointerLeave);

    clearButton.addEventListener("click", () => {
      const level = getActiveLevel();
      if (!level) {
        return;
      }
      level.walls.length = 0;
      level.rooms.length = 0;
      updateRoomList();
      render();
      persistState();
    });

    undoButton.addEventListener("click", () => {
      const level = getActiveLevel();
      if (!level) {
        return;
      }
      if (activeTool === "wall" && level.walls.length) {
        level.walls.pop();
      } else if (activeTool === "room" && level.rooms.length) {
        level.rooms.pop();
        updateRoomList();
      } else if (level.walls.length) {
        level.walls.pop();
      } else if (level.rooms.length) {
        level.rooms.pop();
        updateRoomList();
      }
      render();
      persistState();
    });

    window.addEventListener("resize", render);

    loadState();
    updateLevelTabs();
    setActiveLevel(activeLevelId, { persist: false });
    updateRoomList();
    render();

    if (needsInitialPersist) {
      persistState();
    } else if (lastUpdatedAt) {
      scheduleSync(lastUpdatedAt);
    }

    levelNameInput.addEventListener("input", (event) => {
      const level = getActiveLevel();
      if (!level) {
        return;
      }
      const value = event.target.value.trim() || "Unnamed level";
      level.name = value;
      activeLevelBadge.textContent = value;
      updateLevelTabs();
      persistState();
    });

    addLevelButton.addEventListener("click", () => {
      const newLevelIndex = levels.length + 1;
      const level = createLevel(`Level ${newLevelIndex}`);
      levels.push(level);
      persistState();
      updateLevelTabs();
      setActiveLevel(level.id);
    });

    duplicateLevelButton.addEventListener("click", () => {
      const active = getActiveLevel();
      if (!active) {
        return;
      }
      const clone = {
        id: uuid(),
        name: `${active.name} copy`,
        walls: active.walls.map((wall) => ({
          start: { ...wall.start },
          end: { ...wall.end },
        })),
        rooms: active.rooms.map((room) => ({ ...room })),
      };
      levels.push(clone);
      persistState();
      updateLevelTabs();
      setActiveLevel(clone.id);
    });

    deleteLevelButton.addEventListener("click", () => {
      if (levels.length <= 1) {
        return;
      }
      const confirmation = window.confirm(
        "Delete the current level? This cannot be undone and removes its rooms and walls.",
      );
      if (!confirmation) {
        return;
      }
      levels = levels.filter((level) => level.id !== activeLevelId);
      activeLevelId = levels[0].id;
      persistState();
      updateLevelTabs();
      setActiveLevel(activeLevelId);
    });

    exportPlanButton.addEventListener("click", () => {
      const exportData = buildPlanPayload({
        includeExportMetadata: true,
        timestamp: lastUpdatedAt || new Date().toISOString(),
      });
      const blob = new Blob([JSON.stringify(exportData, null, 2)], {
        type: "application/json",
      });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = `altinet-floorplan-${Date.now()}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    });
  })();
</script>
{% endblock %}
